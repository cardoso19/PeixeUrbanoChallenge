//
//  CatalogInteractor.swift
//  PeixeUrbano
//
//  Created by Matheus Cardoso kuhn on 20/07/19.
//  Copyright (c) 2019 MDT. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CatalogBusinessLogic {
    /// Select the screen's catalog type.
    ///
    /// - Parameter request: The data to create a request.
    func selectCatalogType(request: Catalog.TypeModel.Request)
    /// Do the catalog request.
    func doCatalogRequest()
    /// Do the image's download request.
    ///
    /// - Parameter request: The data to create a request.
    func doDownloadImage(request: Catalog.ImageModel.Request)
    /// Do all the banners' image download request.
    ///
    /// - Parameter request: The data to create a request.
    func doDownloadBanners(request: Catalog.Banners.Request)
    /// Do the enable or disable logic of the favorite button.
    ///
    /// - Parameter request: The data to create a request.
    func doFavorite(request: Catalog.Favorite.Request)
}

protocol CatalogDataStore {
    /// The type of catalog showed on the screen.
    var type: CatalogType! { get set }
    /// The deals showed on the screen.
    var deals: [Deal]? { get set }
}

class CatalogInteractor: CatalogBusinessLogic, CatalogDataStore {
    
    // MARK: - Variables
    var presenter: CatalogPresentationLogic?
    var worker = CatalogWorker()
    var type: CatalogType!
    var deals: [Deal]?
    
    // MARK: - Catalog
    func selectCatalogType(request: Catalog.TypeModel.Request) {
        type = request.type
    }
    
    func doCatalogRequest() {
        presenter?.presentLoader(response: Catalog.Loader.Response(isLoaderVisible: true))
        let completion: (Result<ServerResponse<CatalogReponse>, Error>) -> Void = { [weak self] result in
            self?.presenter?.presentLoader(response: Catalog.Loader.Response(isLoaderVisible: false))
            switch result {
            case .success(let serverResponse):
                self?.deals = serverResponse.response.deals
                self?.presenter?.presentCatalog(response: Catalog.CatalogModel.Response(catalog: serverResponse.response))
            case .failure(let error):
                self?.presenter?.presentError(response: error)
            }
        }
        worker.requestDeals(request: Catalog.CatalogModel.Request(type: type,
                                                                  completion: completion))
    }
    
    func doDownloadImage(request: Catalog.ImageModel.Request) {
        let completion: (Result<UIImage, Error>) -> Void = { [weak self] result in
            switch result {
            case .success(let image):
                self?.presenter?.presentImage(response: Catalog.ImageModel.Response(image: image,
                                                                                    indexPath: request.indexPath))
            case .failure(let error):
                self?.presenter?.presentError(response: error)
            }
        }
        worker.requestImage(request: Catalog.ImageModel.WorkerRequest(url: request.url,
                                                                      completion: completion))
    }
    
    func doDownloadBanners(request: Catalog.Banners.Request) {
        let completion: (Int, Result<UIImage, Error>) -> Void = { [weak self] index, result in
            switch result {
            case .success(let image):
                self?.presenter?.presentBanner(response: Catalog.Banners.Response(image: image,
                                                                                  index: index))
            case .failure(let error):
                self?.presenter?.presentError(response: error)
            }
        }
        for (index, banner) in request.banners.enumerated() {
            worker.requestBanner(request: Catalog.Banners.WorkerRequest(url: banner.imageUrl,
                                                                        index: index,
                                                                        completion: completion))
        }
    }
    
    func doFavorite(request: Catalog.Favorite.Request) {
        guard let isFavorite = deals?[request.row].isFavorite else { return }
        deals?[request.row].isFavorite = !isFavorite
        let response = Catalog.Favorite.Response(isFavorite: !isFavorite, row: request.row)
        presenter?.presentFavorite(response: response)
    }
}
